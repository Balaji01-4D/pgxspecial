package dbcommands

import (
	"context"
	"fmt"
	"strconv"
	"strings"

	"github.com/balaji01-4d/pgspecial/pgspecial"
	"github.com/balaji01-4d/pgspecial/pgspecial/database"
	"github.com/jackc/pgx/v5"
)

func init() {
	pgspecial.RegisterCommand(pgspecial.SpecialCommandRegistry{
		Cmd:         "\\d",
		Description: "List or describe tables, views and sequences.",
		Syntax:      "\\d[+] [pattern]",
		Handler: func(ctx context.Context, db database.DB, pattern string, verbose bool) (pgx.Rows, error) {
			rowsList, err := DescribeTableDetails(ctx, db, pattern, verbose)
			if err != nil {
				return nil, err
			}
			if len(rowsList) == 0 {
				return nil, nil
			}
			return rowsList[0], nil
		},
		CaseSensitive: true,
	})

	pgspecial.RegisterCommand(pgspecial.SpecialCommandRegistry{
		Cmd:         "DESCRIBE",
		Description: "",
		Syntax:      "DESCRIBE [pattern]",
		Handler: func(ctx context.Context, db database.DB, pattern string, verbose bool) (pgx.Rows, error) {
			rowsList, err := DescribeTableDetails(ctx, db, pattern, verbose)
			if err != nil {
				return nil, err
			}
			if len(rowsList) == 0 {
				return nil, nil
			}
			return rowsList[0], nil
		},
		CaseSensitive: false,
	})
}

func DescribeTableDetails(ctx context.Context, db database.DB, pattern string, verbose bool) ([]pgx.Rows, error) {
	if pattern == "" {
		rows, err := ListObjects(ctx, db, pattern, verbose, []string{"r", "p", "v", "m", "S", "f", ""})
		if err != nil {
			return nil, err
		}
		return []pgx.Rows{rows}, nil
	}

	schema, relname := sqlNamePattern(pattern)
	var sb strings.Builder
	args := []any{}
	argIndex := 1

	sb.WriteString(`
		SELECT c.oid, n.nspname, c.relname
		FROM pg_catalog.pg_class c
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
		WHERE 1=1
	`)

	if schema != "" {
		sb.WriteString(" AND n.nspname ~ $" + strconv.Itoa(argIndex))
		args = append(args, schema)
		argIndex++
	} else {
		sb.WriteString(" AND pg_catalog.pg_table_is_visible(c.oid)")
	}

	if relname != "" {
		sb.WriteString(" AND c.relname OPERATOR(pg_catalog.~) $" + strconv.Itoa(argIndex))
		args = append(args, relname)
		argIndex++
	}

	sb.WriteString(" ORDER BY 2, 3")

	rows, err := db.Query(ctx, sb.String(), args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []pgx.Rows
	found := false

	for rows.Next() {
		found = true
		var oid uint32
		var nspname, relnameStr string
		if err := rows.Scan(&oid, &nspname, &relnameStr); err != nil {
			return nil, err
		}

		// Assuming DescribeOneTableDetails is defined in the same package
		// and returns (pgx.Rows, error)
		res, err := DescribeOneTableDetails(ctx, db, nspname, relnameStr, oid, verbose)
		if err != nil {
			return nil, err
		}
		results = append(results, res)
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}

	if !found {
		return nil, fmt.Errorf("did not find any relation named %s", pattern)
	}

	return results, nil
}

func DescribeOneTableDetails(ctx context.Context, db database.DB, schemaName, relationName string, oid uint32, verbose bool) (pgx.Rows, error) {
	var relKind string
	err := db.QueryRow(ctx, "SELECT relkind::text FROM pg_catalog.pg_class WHERE oid = $1", oid).Scan(&relKind)
	if err != nil {
		return nil, err
	}

	var sb strings.Builder
	args := []any{oid}

	sb.WriteString("SELECT ")

	cols := []string{
		`a.attname AS "Column"`,
		`pg_catalog.format_type(a.atttypid, a.atttypmod) AS "Type"`,
	}

	if relKind == "r" || relKind == "p" || relKind == "v" || relKind == "m" || relKind == "f" || relKind == "c" {
		cols = append(cols, `
			TRIM(BOTH ' ' FROM CONCAT(
				CASE WHEN a.attcollation <> t.typcollation THEN 'collate ' || c.collname ELSE '' END,
				CASE WHEN a.attnotnull THEN ' not null' ELSE '' END,
				CASE WHEN a.atthasdef THEN ' default ' || pg_catalog.pg_get_expr(d.adbin, d.adrelid, true) ELSE '' END,
				CASE WHEN a.attidentity = 'a' THEN ' generated always as identity'
					 WHEN a.attidentity = 'd' THEN ' generated by default as identity'
					 WHEN a.attgenerated = 's' THEN ' generated always as (' || pg_catalog.pg_get_expr(d.adbin, d.adrelid, true) || ') stored'
					 ELSE '' END
			)) AS "Modifiers"`)
	}

	if relKind == "i" || relKind == "I" {
		cols = append(cols, `pg_catalog.pg_get_indexdef(a.attrelid, a.attnum, TRUE) AS "Definition"`)
	}

	if relKind == "f" {
		cols = append(cols, `CASE WHEN attfdwoptions IS NULL THEN '' ELSE '(' || array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(attfdwoptions)), ', ') || ')' END AS "FDW Options"`)
	}

	if verbose {
		cols = append(cols, `a.attstorage AS "Storage"`)
		if relKind == "r" || relKind == "i" || relKind == "I" || relKind == "m" || relKind == "f" || relKind == "p" {
			cols = append(cols, `CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS "Stats target"`)
		}
		if relKind == "r" || relKind == "v" || relKind == "m" || relKind == "f" || relKind == "p" || relKind == "c" {
			cols = append(cols, `pg_catalog.col_description(a.attrelid, a.attnum) AS "Description"`)
		}
	}

	sb.WriteString(strings.Join(cols, ",\n"))

	sb.WriteString(`
		FROM pg_catalog.pg_attribute a
		LEFT JOIN pg_catalog.pg_attrdef d ON d.adrelid = a.attrelid AND d.adnum = a.attnum
		LEFT JOIN pg_catalog.pg_type t ON t.oid = a.atttypid
		LEFT JOIN pg_catalog.pg_collation c ON c.oid = a.attcollation
		WHERE a.attrelid = $1 AND a.attnum > 0 AND NOT a.attisdropped
		ORDER BY a.attnum
	`)

	return db.Query(ctx, sb.String(), args...)
}
